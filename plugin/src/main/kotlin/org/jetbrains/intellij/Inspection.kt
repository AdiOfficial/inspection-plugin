package org.jetbrains.intellij

import groovy.lang.Closure
import groovy.lang.DelegatesTo
import org.gradle.BuildListener
import org.gradle.BuildResult
import org.gradle.api.Action
import org.gradle.api.file.FileCollection
import org.gradle.api.file.FileTree
import org.gradle.api.initialization.Settings
import org.gradle.api.internal.ClosureBackedAction
import org.gradle.api.invocation.Gradle
import org.gradle.api.plugins.quality.CheckstyleReports
import org.gradle.api.reporting.Reporting
import org.gradle.api.tasks.*
import org.jdom2.input.SAXBuilder
import java.io.File
import org.gradle.api.Project as GradleProject
import java.lang.Exception
import java.net.URLClassLoader
import java.util.*
import java.util.function.BiFunction
import kotlin.concurrent.thread

@Suppress("MemberVisibilityCanBePrivate")
@CacheableTask
open class Inspection : SourceTask(), VerificationTask, Reporting<CheckstyleReports> {

    companion object {
        // TODO: take the same version as plugin
        const val runnerVersion = "0.1.4"
    }

    object ClassloaderContainer {
        @JvmField
        var customClassLoader: ClassLoader? = null

        fun getOrInit(init: () -> ClassLoader): ClassLoader {
            return customClassLoader ?: init().apply {
                customClassLoader = this
            }
        }
    }

    /**
     * The class path containing the compiled classes for the source files to be analyzed.
     */
    @get:Classpath
    lateinit var classpath: FileCollection

    /**
     * The configuration file name to use. Replaces the `configFile` property.
     */
    var config: String
        get() = extension.config
        set(value) {
            extension.config = value
        }

    private val reports = IdeaCheckstyleReports(this)

    private val extension: InspectionPluginExtension
        get() = project.extensions.findByType(InspectionPluginExtension::class.java)!!

    /**
     * Tool (IDEA) version to use
     */
    @Suppress("unused")
    var toolVersion: String
        @Input get() = extension.toolVersion
        set(value) {
            extension.toolVersion = value
        }

    /**
     * The maximum number of errors that are tolerated before stopping the build
     * and setting the failure property (the last if ignoreFailures = false only)
     *
     * @return the maximum number of errors allowed
     */
    var maxErrors: Int
        @Input get() = extension.maxErrors
        set(value) {
            extension.maxErrors = value
        }

    /**
     * The maximum number of warnings that are tolerated before stopping the build
     * and setting the failure property (the last if ignoreFailures = false only)
     *
     * @return the maximum number of warnings allowed
     */
    var maxWarnings: Int
        @Input get() = extension.maxWarnings
        set(value) {
            extension.maxWarnings = value
        }

    /**
     * Whether rule violations are to be displayed on the console.
     *
     * @return false if violations should be displayed on console, true otherwise
     */
    @get:Console
    var quiet: Boolean
        @Input get() = extension.isQuiet
        set(value) {
            extension.isQuiet = value
        }


    /**
     * The configuration file to use.
     */
    var configFile: File
        @InputFile
        get() {
            return File(project.rootProject.projectDir, config)
        }
        set(value) {
            config = value.relativeTo(project.rootProject.projectDir).path
        }

    /**
     * Configures the reports to be generated by this task.
     *
     * The contained reports can be configured by name and closures. Example:
     *
     * <pre>
     * inspection {
     *     reports {
     *         html {
     *             destination "build/codenarc.html"
     *         }
     *         xml {
     *             destination "build/report.xml"
     *         }
     *     }
     * }
     * </pre>
     *
     *
     * @param closure The configuration
     * @return The reports container
     */
    override fun reports(
            @DelegatesTo(value = CheckstyleReports::class, strategy = Closure.DELEGATE_FIRST) closure: Closure<*>
    ): CheckstyleReports = reports(ClosureBackedAction(closure))

    /**
     * Configures the reports to be generated by this task.
     *
     * The contained reports can be configured by name and closures. Example:
     *
     * <pre>
     * checkstyleTask {
     *     reports {
     *         html {
     *             destination "build/codenarc.html"
     *         }
     *     }
     * }
     * </pre>
     *
     * @param configureAction The configuration
     * @return The reports container
     */
    override fun reports(configureAction: Action<in CheckstyleReports>): CheckstyleReports {
        configureAction.execute(reports)
        return reports
    }

    private fun readInspectionClassesFromConfigFile(): InspectionClassesSuite {
        val builder = SAXBuilder()
        logger.info("Configuration file: ${configFile.path}")
        val document = builder.build(configFile)
        val root = document.rootElement

        val inheritFromIdea = root.getChild("inheritFromIdea")
        if (inheritFromIdea != null) {
            return InspectionClassesSuite(inheritFromIdea.getAttributeValue("profileName"))
        }
        val errorClasses = root.getChild("errors").children.map { it.getAttributeValue("class") }
        val warningClasses = root.getChild("warnings").children.map { it.getAttributeValue("class") }
        val infoClasses = root.getChild("infos").children.map { it.getAttributeValue("class") }

        return InspectionClassesSuite(errorClasses, warningClasses, infoClasses)
    }

    private fun tryResolveRunnerJar(project: org.gradle.api.Project): File = try {
        val dependency = project.buildscript.dependencies.create(
                "org.jetbrains.intellij.plugins:inspection-runner:$runnerVersion"
        )
        val configuration = project.buildscript.configurations.detachedConfiguration(dependency)
        configuration.description = "Runner main jar"
        configuration.resolve().first()
    } catch (e: Exception) {
        project.parent?.let { tryResolveRunnerJar(it) } ?: throw e
    }

    private var analyzer: Analyzer? = null

    @Suppress("unused")
    @TaskAction
    fun run() {
        try {
            val ideaDirectory = with (UnzipTask) { this@Inspection.project.cacheDirectory }
            val ideaClasspath = listOf(
                File(ideaDirectory, "lib")
            ).map {
                it.listFiles { dir, name -> name.endsWith("jar") && "xmlrpc" !in name }.toList()
            }.flatten()
            val fullClasspath = (listOf(tryResolveRunnerJar(project)) + ideaClasspath).map { it.toURI().toURL() }
            logger.info("Inspection runner classpath: $fullClasspath")
            val parentClassLoader = this.javaClass.classLoader
            logger.info("Inspection runner parent class loader: $parentClassLoader")
            if (parentClassLoader is URLClassLoader) {
                logger.info("Parent classpath: ${Arrays.toString(parentClassLoader.urLs)}")
            }
            val loader = ClassloaderContainer.getOrInit {
                ChildFirstClassLoader(
                        classpath = fullClasspath.toTypedArray(),
                        parent = parentClassLoader
                )
            }

            val inspectionClasses = readInspectionClassesFromConfigFile()
            var success = true
            val inspectionsThread = thread(start = false) {
                @Suppress("UNCHECKED_CAST")
                val analyzerClass = loader.loadClass(
                        "org.jetbrains.idea.inspections.InspectionRunner"
                ) as Class<Analyzer>
                val analyzer = analyzerClass.constructors.first().newInstance(
                        project.rootProject.projectDir.absolutePath,
                        inspectionClasses,
                        extension.testMode
                ).let { analyzerClass.cast(it) }
                analyzer.setLogger(BiFunction { level, message ->
                    when (level) {
                        0 -> logger.error(message)
                        1 -> logger.warn(message)
                        2 -> logger.info(message)
                        else -> {}
                    }
                })
                this.analyzer = analyzer
                var gradle: Gradle = project.gradle
                while (true) {
                    gradle = gradle.parent ?: break
                }
                gradle.addBuildListener(IdeaFinishingListener())
                success = analyzer.analyzeTreeAndLogResults(
                        files = getSource().files,
                        ideaProjectFileName = project.rootProject.name,
                        ideaModuleName = project.name,
                        ideaHomeDirectory = ideaDirectory,
                        maxErrors = maxErrors,
                        maxWarnings = maxWarnings,
                        quiet = quiet,
                        xmlReport = if (reports.xml.isEnabled) reports.xml.destination else null,
                        htmlReport = if (reports.html.isEnabled) reports.html.destination else null
                )
            }
            inspectionsThread.contextClassLoader = loader
            inspectionsThread.setUncaughtExceptionHandler { t, e ->
                logger.error(e.message)
                throw TaskExecutionException(this, e)
            }
            inspectionsThread.start()
            inspectionsThread.join()

            if (!success && !ignoreFailures) {
                throw TaskExecutionException(this, null)
            }
        }
        catch (e: Throwable) {
            logger.error("EXCEPTION caught in inspections plugin: " + e.message)
            throw TaskExecutionException(this, e)
        }
    }

    /**
     * {@inheritDoc}
     *
     *
     * The sources for this task are relatively relocatable even though it produces output that
     * includes absolute paths. This is a compromise made to ensure that results can be reused
     * between different builds. The downside is that up-to-date results, or results loaded
     * from cache can show different absolute paths than would be produced if the task was
     * executed.
     */
    @PathSensitive(PathSensitivity.RELATIVE)
    override fun getSource(): FileTree = super.getSource()

     /**
     * The reports to be generated by this task.
     */
    @Nested
    override fun getReports(): CheckstyleReports = reports

    /**
     * Whether or not this task will ignore failures and continue running the build.
     *
     * @return true if failures should be ignored
     */
    @Input
    override fun getIgnoreFailures(): Boolean = extension.isIgnoreFailures

    /**
     * Whether this task will ignore failures and continue running the build.
     */
    override fun setIgnoreFailures(ignoreFailures: Boolean) {
        extension.isIgnoreFailures = ignoreFailures
    }

    fun setSourceSet(source: FileTree) {
        setSource(source as Any)
    }

    inner class IdeaFinishingListener : BuildListener {
        override fun buildFinished(result: BuildResult?) {
            analyzer?.shutdownIdea()
            analyzer = null
        }

        override fun projectsLoaded(gradle: Gradle?) {}

        override fun buildStarted(gradle: Gradle?) {}

        override fun projectsEvaluated(gradle: Gradle?) {}

        override fun settingsEvaluated(settings: Settings?) {}
    }
}